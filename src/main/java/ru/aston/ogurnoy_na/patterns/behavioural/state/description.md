# Описание паттерна "Состояние" (State)

## Назначение
Паттерн **State** позволяет объекту изменять своё поведение при изменении внутреннего состояния. Каждое состояние инкапсулируется в отдельный класс, что упрощает добавление новых состояний и изменение логики.

## Структура
1. **State** (интерфейс):
    - Определяет методы для всех возможных действий, зависящих от состояния.
2. **ConcreteState** (конкретные состояния):
    - Реализуют поведение, специфичное для определённого состояния (например, `PlayState`, `PauseState`).
3. **Context** (контекст):
    - Хранит ссылку на текущее состояние и делегирует ему выполнение операций.

## Пример использования
В примере с аудиоплеером:
- **PlayerContext** управляет состояниями: `PlayState`, `PauseState`, `StopState`.
- При вызове методов `play()`, `pause()`, `stop()` контекст делегирует выполнение текущему состоянию.

**Вывод программы:**
```
Начинаем воспроизведение ▶️
Пауза ▶️⏸️
Продолжаем воспроизведение ⏯️▶️
Остановка ⏸️⏹️
Невозможно поставить на паузу — трек остановлен!
```

## Преимущества
- **Упрощение кода**: Логика состояний изолирована в отдельных классах.
- **Гибкость**: Легко добавлять новые состояния без изменения существующего кода.
- **Инкапсуляция**: Переходы между состояниями управляются явно.

## Недостатки
- **Усложнение структуры**: Много классов для простых сценариев.
- **Накладные расходы**: Переключение между состояниями может требовать создания новых объектов.

## Когда использовать?
- Когда поведение объекта зависит от его состояния и должно изменяться во время выполнения.
- Примеры:
    - Управление заказами (создан, оплачен, доставлен).
    - Игровые персонажи (бег, прыжок, атака).
    - Документы (черновик, на проверке, опубликован).