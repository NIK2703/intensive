# Описание паттерна "Шаблонный метод" (Template Method)

## Назначение
Паттерн **Шаблонный метод** определяет основу алгоритма в абстрактном классе, позволяя подклассам переопределять отдельные шаги алгоритма, не меняя его структуры. Это способствует повторному использованию кода и соблюдению принципа **Hollywood** ("Не вызывайте нас, мы сами вас вызовем").

## Структура
1. **AbstractClass** (абстрактный класс):
    - Содержит шаблонный метод `templateMethod()`, который вызывает:
        - Примитивные методы (`abstract`), реализуемые подклассами.
        - Конкретные методы (общие для всех подклассов).
        - Хуки (методы с реализацией по умолчанию, которые можно переопределить).

2. **ConcreteClass** (конкретные подклассы):
    - Реализуют примитивные методы из абстрактного класса.

## Пример использования
В примере с напитками:
- **Beverage** задает алгоритм приготовления: `boilWater() → brew() → pourInCup() → addCondiments()`.
- **Tea** и **Coffee** переопределяют `brew()` и `addCondiments()`.

**Вывод программы:**
```
Готовим чай:
Кипятим воду
Завариваем чайные листья
Наливаем в чашку
Добавляем лимон

Готовим кофе:
Кипятим воду
Завариваем кофе
Наливаем в чашку
Добавляем молоко и сахар
```

## Преимущества
- **Повторное использование кода**: Общая логика сосредоточена в абстрактном классе.
- **Гибкость**: Подклассы контролируют только свои шаги, не затрагивая алгоритм.
- **Соблюдение DRY**: Избегание дублирования кода в подклассах.

## Недостатки
- **Жёсткая структура**: Изменение алгоритма требует модификации абстрактного класса.
- **Ограниченная гибкость**: Если подклассам нужно менять порядок шагов, паттерн не подходит.

## Когда использовать?
- Когда нужно задать общий алгоритм, но позволить подклассам настраивать отдельные этапы.
- Примеры:
    - Обработка данных (шаги: чтение → преобразование → сохранение).
    - Игровые движки (инициализация → обновление состояния → рендеринг).
    - Фильтрация контента (шаги загрузки → анализа → модификации).