# Описание паттерна "Наблюдатель" (Observer)

## Назначение
Паттерн **Наблюдатель** определяет зависимость **«один ко многим»** между объектами так, что при изменении состояния одного объекта (субъекта) все зависящие от него объекты (наблюдатели) автоматически уведомляются и обновляются.  
Основные цели:
- Минимизация связанности между компонентами системы.
- Реализация механизма подписки на события.

## Структура

1. **`Subject` (Субъект)**:
    - Интерфейс для управления наблюдателями: методы `registerObserver()`, `removeObserver()`, `notifyObservers()`.
2. **`ConcreteSubject` (Конкретный субъект)**:
    - Хранит состояние, которое интересует наблюдателей.
    - При изменении состояния вызывает `notifyObservers()`.
3. **`Observer` (Наблюдатель)**:
    - Интерфейс с методом `update()`, который вызывается субъектом для уведомления.
4. **`ConcreteObserver` (Конкретный наблюдатель)**:
    - Реализует реакцию на изменение состояния субъекта.

## Пример использования
```java
NewsAgency agency = new NewsAgency();
Observer channel = new NewsChannel("Новостной канал");
agency.registerObserver(channel);
agency.setNews("Важное событие!"); // Наблюдатель получит уведомление
```

## Преимущества
- **Слабая связанность**: Субъект и наблюдатели не зависят друг от друга напрямую.
- **Динамическая подписка**: Наблюдатели могут добавляться/удаляться в runtime.
- **Автоматическое распространение изменений**: Все наблюдатели получают уведомления без явного вызова их методов.

## Недостатки
- **Неконтролируемые уведомления**: Наблюдатели могут получать ненужные обновления.
- **Риск утечек памяти**: Если забыть удалить наблюдатель, субъект будет хранить ссылку на него.

## Применимость
- Когда изменение состояния одного объекта требует изменения других, но их количество и типы заранее неизвестны.
- В системах событийно-ориентированной архитектуры (GUI, уведомления, игры).
- Для реализации механизмов подписки (например, рассылка email-новостей).

---

**Примечание**: В Java паттерн можно реализовать с помощью `java.util.Observable` и `java.util.Observer`, но эти классы считаются устаревшими. Лучше использовать собственную реализацию или библиотеки (например, **RxJava**).