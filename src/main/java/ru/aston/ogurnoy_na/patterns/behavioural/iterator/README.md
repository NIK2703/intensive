# Описание паттерна "Итератор" (Iterator)

## Назначение
Паттерн **Итератор** предоставляет способ последовательного доступа к элементам коллекции, **не раскрывая её внутренней структуры**. Основные цели:
- Единый интерфейс для обхода разных типов коллекций.
- Разделение логики обхода и хранения данных.
- Упрощение взаимодействия с составными объектами.

## Структура

1. **`Iterator`**:
    - Интерфейс с методами `hasNext()` и `next()`.
2. **`ConcreteIterator`**:
    - Реализует логику обхода конкретной коллекции.
3. **`IterableCollection`** (или `Aggregate`):
    - Интерфейс для создания итератора.
4. **`ConcreteCollection`**:
    - Реализует методы для работы с данными и возвращает связанный итератор.

## Пример использования
```java
TaskList taskList = new TaskList();
taskList.addTask("Задача 1");
taskList.addTask("Задача 2");

Iterator<String> iterator = taskList.createIterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

## Преимущества
- **Инкапсуляция коллекции**: Клиент не знает, как хранятся данные (список, массив, дерево и т.д.).
- **Универсальный доступ**: Единый интерфейс для обхода любых коллекций.
- **Несколько итераторов**: Одновременный обход коллекции разными способами.
- **Открытость/закрытость**: Легко добавить новый тип итератора без изменения коллекции.

## Недостатки
- **Избыточность**: Для простых коллекций паттерн может усложнить код.
- **Производительность**: В некоторых случаях прямое обращение к элементам эффективнее.

## Применимость
- Когда нужно скрыть внутреннюю структуру данных от клиента.
- Для поддержки разных способов обхода (например, прямой/обратный порядок).
- Когда требуется единый интерфейс для работы с разнородными коллекциями (списки, деревья, графы).

---

**Примечание**: В Java паттерн реализован через интерфейсы `java.util.Iterator` и `java.lang.Iterable`. Пример выше демонстрирует собственную реализацию для понимания паттерна.