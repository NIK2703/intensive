# Описание паттерна "Компоновщик" (Composite)

## Назначение
Паттерн **Composite** позволяет работать с древовидными структурами, где **отдельные объекты** (листья) и **их композиции** (узлы) обрабатываются единообразно. Клиенты могут игнорировать разницу между простыми и составными элементами.

## Структура
1. **Component** (интерфейс):
    - Определяет общие операции для всех элементов (например, `showDetails()`).
2. **Leaf** (лист):
    - Представляет конечные объекты (не может содержать другие компоненты).
3. **Composite** (составной элемент):
    - Содержит коллекцию дочерних компонентов и реализует операции для управления ими.

## Пример использования
В примере с файловой системой:
- **File** (лист) — отдельный файл.
- **Directory** (композит) — папка, содержащая файлы и другие папки.
- Клиент работает с корневой директорией, не зная о внутренней структуре.

**Вывод программы:**
```
Директория: Корневая папка
Содержимое (3 элементов):

Директория: Документы
Содержимое (2 элементов):
Файл: resume.pdf      | Размер: 2,5 MB
Файл: notes.txt       | Размер: 0,3 MB

Директория: Изображения
Содержимое (1 элементов):
Файл: photo.jpg       | Размер: 5,8 MB

Файл: readme.md       | Размер: 0,1 MB
```

## Преимущества
- **Упрощение клиентского кода**: Одинаковая обработка листьев и композитов.
- **Масштабируемость**: Легко добавлять новые типы компонентов.
- **Гибкость структуры**: Динамическое построение сложных деревьев.

## Недостатки
- **Нарушение инкапсуляции**: Композиты предоставляют доступ к внутренней структуре.
- **Сложность ограничений**: Трудно запретить добавление определенных типов компонентов.

## Когда использовать?
- Когда нужно представить иерархию объектов типа "часть-целое".
- Примеры:
    - GUI-элементы (контейнеры и виджеты).
    - Структура организаций (отделы и сотрудники).
    - Математические выражения (операторы и числа).