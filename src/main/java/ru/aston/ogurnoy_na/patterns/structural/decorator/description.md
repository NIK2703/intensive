# Паттерн Декоратор (Decorator)

## Назначение
Паттерн **Декоратор** позволяет динамически добавлять объектам новые функциональные возможности, оборачивая их в объекты-декораторы. Это гибкая альтернатива наследованию для расширения поведения.

## Структура

1. **`Component` (Компонент)**:
    - Определяет интерфейс для объектов, которые могут быть динамически дополнены (например, `Coffee`).

2. **`ConcreteComponent` (Конкретный компонент)**:
    - Базовый объект, к которому добавляются новые возможности (например, `SimpleCoffee`).

3. **`Decorator` (Декоратор)**:
    - Содержит ссылку на `Component` и реализует его интерфейс (например, `CoffeeDecorator`).

4. **`ConcreteDecorator` (Конкретный декоратор)**:
    - Добавляет конкретную функциональность к компоненту (например, `Milk`, `Sugar`).

## Преимущества
- **Гибкость**: Добавляет новые обязанности без создания подклассов.
- **Динамическое изменение**: Декораторы можно комбинировать в любом порядке.
- **Соблюдение Open/Closed Principle**: Код компонента не меняется при добавлении новых декораторов.

## Недостатки
- **Сложность отладки**: Множество слоев декораторов могут усложнить понимание кода.
- **Много мелких классов**: Каждая новая функция требует создания отдельного декоратора.

## Когда использовать?
- Нужно добавлять обязанности объектам во время выполнения.
- Нельзя расширить функциональность через наследование (например, класс объявлен как `final`).
- Требуется гибкое сочетание различных функций.

## Примеры применения
- **Графические интерфейсы**: Добавление рамок, теней к элементам.
- **Потоки ввода-вывода в Java**: `BufferedReader`, `ZipInputStream` и др.
- **Валидация данных**: Последовательное применение проверок.

## Пример из кода
- `SimpleCoffee` — базовый компонент.
- `Milk` и `Sugar` — декораторы, добавляющие описание и стоимость.
- Клиентский код комбинирует декораторы:
  ```java
  Coffee coffee = new Milk(new Sugar(new SimpleCoffee()));
  ```